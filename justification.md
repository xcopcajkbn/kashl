**Experimental justifications.**
We deploy a `geth` client to our local machine, synchronize it with the state data from the main branch of Ethereum, and create three test forks based on the main branch to justify overcharging issues, respectively. We hack the `geth` client to let it process customized blocks, transactions, and contracts in our forks. To make a case study, we create a smart contract `Token`, which includes a constructor to initialize the balances of three accounts, say A, B, and C, as well as a function to transfer tokens from one account to another. We confirm an initial block in each test fork with a transaction `Tx[Token]` to deploy `Token` and initialize accounts, and also manually clean caches (after the confirmation of the block) to avoid affecting charges for following access.

To justify Issue#1, we create a block, which includes two transactions to transfer tokens from A to B (i.e., `Tx1[A->B]`), and A to C (i.e., `Tx2[A->C]`), respectively. The difference is that `Tx1[A->B]` needs to load the balances of both A and B from disks to memory, while the access to the balance of A in `Tx2[A->C]` should charge memory fees. We process the block on `geth`, aissuend hack `geth` to print the gas costs of operations on states, as well as the overall charge of each transaction. Our results show that both transactions cost 32,153 gas in total. By making a breakdown on overall charges, we find that each transaction takes 2,100 gas to read the balances of two accounts, and 2,900 gas to write new balance values. This implies that Ethereum indeed charges the same fees for accessing the balance of A, even if it has been buffered in memory when processing `Tx2[A->C]`.

To justify Issue#2, we create a block, which includes a single transaction to transfer tokens from A to B (i.e., `Tx1[A->B]`). We also create another block to transfer tokens from A to C (i.e., `Tx2[A->C]`). We process the two blocks in sequence without cleaning caches, such that the balance of A will be buffered in *SSAS* cache after processing `Tx1[A->B])`. We find that both transactions have the same gas cost in overall and breakdown as in Issue#1. This implies that Ethereum does not consider the impact of *SSAS* cache on TFM, and charges the same fees for accessing the balance of A in both `Tx1[A->B]` and `Tx2[A->C]`.

To justify Issue#3, we create a block that includes a single transaction `Tx'[Token']` to deploy the smart contract `Token'`, which has the same bytecode as `Token` deployed in the initial block during the experiment setup. We process the block to ensure that the smart contract `Token'` is deployed with the same bytecode as `Token`, and monitor the gas costs of `Tx[Token]` and `Tx'[Token']`, respectively. We find that both transactions cost 437,026 gas in total, and also take 247,200